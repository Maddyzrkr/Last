import React, { useState, useEffect, useCallback, useRef } from 'react';
import { StyleSheet, Text, View, TouchableOpacity, TextInput, ScrollView, Linking, ActivityIndicator, Alert, Platform } from 'react-native';
import { router } from 'expo-router';
import * as Location from 'expo-location';
// @ts-ignore
import { Ionicons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import UserList from '../../components/UserList';
import RouteDirections from '../../components/RouteDirections';
// Import components from our mock implementation
import { MapLibreView, MapMarker, RouteLayer, UserLocationDot, MapLibreViewMethods, FallbackMap } from '../../components/map';
// Import LocationAutocomplete
import LocationAutocomplete from '../../components/LocationAutocomplete';
// Import the MapAttribution component
import MapAttribution from '../../components/MapAttribution';
import { MAP_STYLES } from '../../utils/config';

// Define interfaces for your types
interface ProviderData {
  name: string;
  eta: string;
  fare: string;
  distance: string;
}

interface RideData {
  provider: string;
  distance: string;
  from: string;
  to: string;
  fare: string;
  id?: string; // Add ride ID for tracking
}

interface Coordinates {
  latitude: number;
  longitude: number;
}

interface User {
  _id: string;
  name: string;
  username: string;
  profileImage?: string;
  location: string;
  languages: string[];
  gender: string;
  rating: number;
  distance: string;
  mode: 'booking' | 'seeking';
  ride?: {
    provider: string;
    destination: string;
    fare: string;
    time: string;
  };
}

interface InviteData {
  userId: string;
  rideId: string;
  status: 'pending' | 'accepted' | 'rejected';
}

// Add route-related interfaces
interface RouteCoordinates {
  type: string;
  coordinates: [number, number][];
}

interface RouteStep {
  instruction: string;
  distance: number;
  duration: number;
}

interface RouteData {
  geometry: RouteCoordinates;
  duration: number; // in seconds
  distance: number; // in meters
  steps: RouteStep[]; // Add steps for directions
}

const API_URL = process.env.EXPO_PUBLIC_API_URL || "http://192.168.0.106:5000";

// Enhanced route helper function with steps
const getRoute = async (startCoord: [number, number], endCoord: [number, number]): Promise<RouteData | null> => {
  try {
    // Using the OSRM demo server - in production, consider setting up your own OSRM instance
    const response = await fetch(
      `https://router.project-osrm.org/route/v1/driving/${startCoord[0]},${startCoord[1]};${endCoord[0]},${endCoord[1]}?overview=full&geometries=geojson&steps=true&annotations=true`
    );
    
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    
    const data = await response.json();
    
    if (data.routes && data.routes.length > 0) {
      // Process and simplify steps from OSRM response
      const processedSteps = data.routes[0].legs[0].steps.map((step: any) => ({
        instruction: step.maneuver.type === 'depart' ? 'Start driving' : step.maneuver.instruction || step.name,
        distance: step.distance,
        duration: step.duration
      }));
      
      return {
        geometry: data.routes[0].geometry,
        duration: data.routes[0].duration,
        distance: data.routes[0].distance,
        steps: processedSteps
      };
    }
    
    return null;
  } catch (error) {
    console.error('Error fetching route:', error);
    return null;
  }
};

// Helper function to format distance
const formatDistance = (meters: number): string => {
  if (meters < 1000) {
    return `${Math.round(meters)} m`;
  }
  return `${(meters / 1000).toFixed(2)} km`;
};

// Helper function to format duration
const formatDuration = (seconds: number): string => {
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  
  if (hours > 0) {
    const remainingMinutes = minutes % 60;
    return `${hours} hr ${remainingMinutes} min`;
  }
  
  return `${minutes} min`;
};

// Add a helper function to handle API calls with proper error handling
const safeApiCall = async (apiCall: () => Promise<any>, fallbackData: any) => {
  try {
    return await apiCall();
  } catch (error) {
    console.error('API call failed:', error);
    return fallbackData;
  }
};

// Helper function to handle network timeouts and errors
const safeNetworkRequest = async <T,>(
  apiCall: () => Promise<T>,
  fallbackData: T,
  timeoutMs: number = 15000,  // Increase default timeout to 15 seconds
  maxRetries: number = 2     // Add retry capability
): Promise<T> => {
  let lastError: any = null;
  
  // Try the request up to maxRetries + 1 times
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        console.log(`Retry attempt ${attempt}/${maxRetries}...`);
        // Add exponential backoff - wait longer between retries
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt - 1)));
      }
      
      // Set up a timeout promise
      const timeoutPromise = new Promise<never>((_, reject) => {
        const id = setTimeout(() => {
          clearTimeout(id);
          reject(new Error(`Network request timeout after ${timeoutMs}ms`));
        }, timeoutMs);
      });

      // Race the API call with the timeout
      const result = await Promise.race([
        apiCall(),
        timeoutPromise
      ]);
      
      console.log('Network request succeeded');
      return result;
    } catch (error) {
      lastError = error;
      console.warn(`Network request failed (attempt ${attempt + 1}/${maxRetries + 1}):`, error);
      
      // If this was our last attempt, break out of the loop
      if (attempt === maxRetries) {
        break;
      }
    }
  }
  
  // If we've used all retries, log and return fallback
  console.error('Network request failed after all retry attempts:', lastError);
  return fallbackData;
};

const Main = () => {
  // Reference to MapLibre map
  const mapRef = useRef<MapLibreViewMethods>(null);
  
  const [location, setLocation] = useState({
    latitude: 19.1136,  // Mumbai default
    longitude: 72.8697,
    latitudeDelta: 0.0922,
    longitudeDelta: 0.0421,
  });
  const [pickupLocation, setPickupLocation] = useState('Current Location');
  const [destination, setDestination] = useState('');
  const [showProviders, setShowProviders] = useState(false);
  const [currentRide, setCurrentRide] = useState<RideData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [destinationCoords, setDestinationCoords] = useState<Coordinates>({
    latitude: 0,
    longitude: 0,
  });
  // Add route state
  const [routeData, setRouteData] = useState<RouteData | null>(null);
  
  const [providers, setProviders] = useState<ProviderData[]>([
    { name: 'Uber', eta: '5 mins', fare: '₹350', distance: '12 miles' },
    { name: 'Ola', eta: '4 mins', fare: '₹330', distance: '12 miles' },
  ]);
  const [availablePartners, setAvailablePartners] = useState<User[]>([]);
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [invites, setInvites] = useState<InviteData[]>([]);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [selectedPartner, setSelectedPartner] = useState<User | null>(null);
  const [isFareSplit, setIsFareSplit] = useState(false);
  const [showPartners, setShowPartners] = useState(false);
  
  // Add state for showing directions
  const [showDirections, setShowDirections] = useState(false);

  // Add state to track map library availability
  const [isMapLibraryAvailable, setIsMapLibraryAvailable] = useState(false);
  
  // Add a state to track initialization
  const [isInitialized, setIsInitialized] = useState(false);
  
  // Add a new state for tracking if destination is confirmed
  const [isDestinationConfirmed, setIsDestinationConfirmed] = useState(false);
  
  // Add state for address
  const [pickupAddress, setPickupAddress] = useState<string>('');
  
  // Function to handle map availability status change
  const handleMapStatusChange = (isAvailable: boolean) => {
    console.log('Map availability changed:', isAvailable);
    // Set to true since we're now using a dev build
    setIsMapLibraryAvailable(true);
  };
  
  // Function to render map content (markers, routes, etc.)
  const renderMapContent = () => {
    if (!isMapLibraryAvailable) {
      return <FallbackMap initialCoordinates={[location.longitude, location.latitude]} />;
    }

    return (
      <MapLibreView
        ref={mapRef}
        style={styles.map}
        initialCoordinates={[location.longitude, location.latitude]}
        styleURL={MAP_STYLES.FALLBACK1} // Use the Stadia Maps style which has better details
        zoomLevel={15} // Higher initial zoom level
        compassEnabled={true}
        attributionEnabled={false}
        logoEnabled={false}
        onMapReady={() => {
          console.log('Map is ready');
          setIsInitialized(true);
          // Explicitly set camera on map ready to ensure proper view
          if (mapRef.current) {
            try {
              mapRef.current.setCamera({
                centerCoordinate: [location.longitude, location.latitude],
                zoomLevel: 15, // Increase initial zoom level
                animationDuration: 300,
                animationMode: 'flyTo'
              });
            } catch (e) {
              console.warn('Error setting initial camera:', e);
            }
          }
        }}
        onAvailabilityChange={handleMapStatusChange}
        onError={(error) => {
          console.error('Map error:', error);
          // Try with fallback URL on error
          if (mapRef.current) {
            try {
              // Set camera on error
              mapRef.current.setCamera({
                centerCoordinate: [location.longitude, location.latitude],
                zoomLevel: 14,
                animationDuration: 500,
                animationMode: 'flyTo'
              });
            } catch (e) {
              console.warn('Error setting camera:', e);
            }
          }
        }}
      >
        {/* User Location Dot */}
        <UserLocationDot visible={true} showHeading={true} />
        
        {/* Display route if available */}
        {routeData && routeData.geometry && (
          <RouteLayer 
            id="routeLayer" 
            coordinates={routeData.geometry.coordinates} 
            color="#0066FF"
            width={5}
          />
        )}
        
        {/* Display destination marker if coordinates are set */}
        {destinationCoords && destinationCoords.latitude !== 0 && (
          <MapMarker
            id="destination"
            coordinate={[destinationCoords.longitude, destinationCoords.latitude]}
          >
            <View style={styles.markerContainer}>
              <Ionicons name="location" size={24} color="#FF3B30" />
            </View>
          </MapMarker>
        )}
      </MapLibreView>
    );
  };
  
  // Add initialization effect - runs once on component mount
  useEffect(() => {
    const initialize = async () => {
      try {
        // Load saved location from AsyncStorage first (fallback)
        await loadSavedLocation();
        
        // Get current location using the existing location retrieval code
        try {
          let { status } = await Location.requestForegroundPermissionsAsync();
          if (status === 'granted') {
            // Create a custom timeout with AbortController
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
              console.warn("Location request timed out after 15 seconds");
              controller.abort();
            }, 15000);

            try {
              // Get current position
              const currentLocation = await Location.getCurrentPositionAsync({
                accuracy: Location.Accuracy.Balanced
              });
              
              // Clear the timeout
              clearTimeout(timeoutId);

              // Update location state with retrieved coordinates
              setLocation({
                ...location,
                latitude: currentLocation.coords.latitude,
                longitude: currentLocation.coords.longitude,
              });
              
              console.log('Successfully retrieved current location');
            } catch (locationError) {
              console.warn('Error getting location in initialize:', locationError);
              // Continue with default location
            }
          } else {
            console.log('Location permission denied, using default location');
          }
        } catch (locationError) {
          console.warn('Error in location retrieval:', locationError);
        }
        
        // Force map library to be available since we're in a dev build
        setIsMapLibraryAvailable(true);
        
        // Mark initialization as complete
        setIsInitialized(true);
      } catch (error) {
        console.error('Initialization error:', error);
        setIsInitialized(true); // Still mark as initialized so UI shows something
      }
    };
    
    initialize();
    
    return () => {
      // Cleanup function
    };
  }, []);

  // Load saved location when component mounts
  const loadSavedLocation = async () => {
    try {
      // Check for pickup location
      const savedPickup = await AsyncStorage.getItem('selectedPickupLocation');
      if (savedPickup) {
        const pickupData = JSON.parse(savedPickup);
        setPickupLocation(pickupData.name);
        
        // Only set location if it's not current location
        if (pickupData.name !== 'Current Location') {
          setLocation({
            ...location,
            latitude: pickupData.latitude,
            longitude: pickupData.longitude,
          });
        }
        
        // Clear the saved data
        await AsyncStorage.removeItem('selectedPickupLocation');
      }
      
      // Check for destination
      const savedDestination = await AsyncStorage.getItem('selectedDestination');
      if (savedDestination) {
        const destData = JSON.parse(savedDestination);
        setDestination(destData.name);
        setDestinationCoords({
          latitude: destData.latitude,
          longitude: destData.longitude,
        });
        // Mark destination as confirmed
        setIsDestinationConfirmed(true);
        
        // Clear the saved data
        await AsyncStorage.removeItem('selectedDestination');
        
        // If we have both pickup and destination, fetch the route
        if ((savedPickup || pickupLocation === 'Current Location') && savedDestination) {
          try {
            // Parse pickup data safely
            const pickupCoords = savedPickup ? JSON.parse(savedPickup) : null;
            
            const startCoords: [number, number] = [
              pickupLocation === 'Current Location' ? location.longitude : (pickupCoords?.longitude || location.longitude),
              pickupLocation === 'Current Location' ? location.latitude : (pickupCoords?.latitude || location.latitude)
            ];
            
            const endCoords: [number, number] = [
              destData.longitude,
              destData.latitude
            ];
            
            const route = await getRoute(startCoords, endCoords);
            if (route) {
              setRouteData(route);
              
              // Update provider info with actual route data
              const updatedProviders = providers.map(provider => ({
                ...provider,
                distance: formatDistance(route.distance),
                eta: formatDuration(route.duration)
              }));
              
              setProviders(updatedProviders);
              setShowProviders(true);
            }
          } catch (parseError) {
            console.error('Error parsing location data:', parseError);
          }
        }
      }
    } catch (error) {
      console.error('Error loading saved location:', error);
    }
  };

  // Function to get current location and address
  const getCurrentLocationAndAddress = async () => {
      try {
      setIsLoading(true);
      const { status } = await Location.requestForegroundPermissionsAsync();
      
        if (status !== 'granted') {
        Alert.alert('Permission Denied', 'Location permission is required to use this feature.');
        setIsLoading(false);
          return;
        }

      const currentLocation = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.Balanced
      });
      
      const { latitude, longitude } = currentLocation.coords;
      
      // Update location state
          setLocation({
            ...location,
        latitude,
        longitude,
      });
      
      // Get address from coordinates using Nominatim
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`,
          {
            headers: {
              'Accept-Language': 'en',
              'User-Agent': 'MatchMyRide RN App'
            }
          }
        );
        
        if (response.ok) {
          const data = await response.json();
          const address = data.display_name.split(',').slice(0, 2).join(',');
          setPickupAddress(address);
          setPickupLocation(address);
        }
      } catch (error) {
        console.error('Error fetching address:', error);
        setPickupLocation('Current Location');
      }
      
      setIsLoading(false);
    } catch (error) {
      console.error('Error getting current location:', error);
      setIsLoading(false);
      Alert.alert('Error', 'Could not get your current location. Please try again.');
    }
  };

  // Validation for pickup and destination
  const validateLocations = () => {
    if (!destination) {
      Alert.alert('Error', 'Please enter a destination');
      return false;
    }
    
    // Check if pickup and destination are the same
    if (isDestinationConfirmed && pickupAddress && destination) {
      // Compare first part of address which typically has the most specific location info
      const pickupMainPart = pickupAddress.split(',')[0].trim().toLowerCase();
      const destMainPart = destination.split(',')[0].trim().toLowerCase();
      
      if (pickupMainPart === destMainPart) {
        Alert.alert('Invalid Route', 'Pickup and destination locations cannot be the same');
        return false;
      }
      
      // Also check coordinates if available
      if (destinationCoords.latitude !== 0 && 
          Math.abs(location.latitude - destinationCoords.latitude) < 0.001 && 
          Math.abs(location.longitude - destinationCoords.longitude) < 0.001) {
        Alert.alert('Invalid Route', 'Pickup and destination locations are too close');
        return false;
      }
    }
    
    return true;
  };

  // Update handleSearch to use validation
  const handleSearch = async () => {
    if (!validateLocations()) {
      return;
    }
    
    // Rest of the existing code...
    if (destinationCoords.latitude !== 0 && destinationCoords.longitude !== 0) {
      setIsLoading(true);
      
      try {
        const startCoords: [number, number] = [location.longitude, location.latitude];
        const endCoords: [number, number] = [destinationCoords.longitude, destinationCoords.latitude];
        
        const route = await getRoute(startCoords, endCoords);
        if (route) {
          setRouteData(route);
          
          // Fit map to show the entire route
          if (mapRef.current) {
            // Create a bounding box that includes both points with proper tuple typing
            const neBound: [number, number] = [
              Math.max(startCoords[0], endCoords[0]) + 0.01,
              Math.max(startCoords[1], endCoords[1]) + 0.01
            ];
            
            const swBound: [number, number] = [
              Math.min(startCoords[0], endCoords[0]) - 0.01,
              Math.min(startCoords[1], endCoords[1]) - 0.01
            ];
            
            mapRef.current.fitBounds(neBound, swBound, 50);
          }
          
          // Update provider info with actual route data
          const updatedProviders = providers.map(provider => ({
            ...provider,
            distance: formatDistance(route.distance),
            eta: formatDuration(route.duration)
          }));
          
          setProviders(updatedProviders);
          fetchProviderData();
        } else {
          // If route fetch fails, still show providers with estimated data
          fetchProviderData();
        }
      } catch (error) {
        console.error('Error getting route:', error);
        fetchProviderData();
      } finally {
        setIsLoading(false);
      }
    } else {
      // If we don't have coordinates, just fetch providers with estimated data
      fetchProviderData();
    }
  };

  const fetchProviderData = async () => {
    try {
      setIsLoading(true);
      const token = await AsyncStorage.getItem('token');
      
      // Default mock providers - removed Rapido
      const mockProviders = [
        { name: 'Uber', eta: '5 mins', fare: '₹350', distance: '12 miles' },
        { name: 'Ola', eta: '4 mins', fare: '₹330', distance: '12 miles' },
      ];
      
      // Set providers directly without API call to avoid errors
      setProviders(mockProviders);
      setShowProviders(true);
    } catch (error) {
      console.error('Error in fetchProviderData:', error);
      
      // Fallback to mock data if API fails - removed Rapido
      setProviders([
        { name: 'Uber', eta: '5 mins', fare: '₹350', distance: '12 miles' },
        { name: 'Ola', eta: '4 mins', fare: '₹330', distance: '12 miles' },
      ]);
      setShowProviders(true);
    } finally {
      setIsLoading(false);
    }
  };

  const selectRideProvider = async (provider: ProviderData) => {
    try {
      setIsLoading(true);
      const token = await AsyncStorage.getItem('token');
      const userId = await AsyncStorage.getItem('userId');
      
      if (!token || !userId) {
        Alert.alert('Error', 'You need to be logged in to book a ride');
        setIsLoading(false);
        return;
      }
      
      // Try to book the ride with the API
      try {
        // Create an AbortController for timeout handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
        
        const response = await fetch(`${API_URL}/api/rides/book`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            userId,
            provider: provider.name,
            pickup: pickupLocation,
            destination,
            fare: provider.fare,
            distance: provider.distance
          }),
          signal: controller.signal
        });
        
        // Clear the timeout
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error('Failed to book ride');
        }
        
        const result = await response.json();
        
        // Set the current ride with the API-provided ID
        setCurrentRide({
          provider: provider.name,
          distance: provider.distance,
          from: pickupLocation,
          to: destination,
          fare: provider.fare,
          id: result.rideId
        });
        
        console.log('Ride booked successfully with ID:', result.rideId);
      } catch (error) {
        console.error('API call failed:', error);
        
        // Create a temporary ride ID
        const tempRideId = `temp-${Date.now()}`;
        
        // Set the current ride with a temporary ID
        setCurrentRide({
          provider: provider.name,
          distance: provider.distance,
          from: pickupLocation,
          to: destination,
          fare: provider.fare,
          id: tempRideId
        });
        
        console.log('Created temporary ride with ID:', tempRideId);
      }
    } catch (error) {
      console.error('Error in ride booking process:', error);
      Alert.alert('Error', 'Failed to book ride. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const findRidePartners = () => {
    // Navigate to the nearby screen
    try {
      router.push('/nearby');
    } catch (error) {
      console.error('Error navigating to nearby screen:', error);
      Alert.alert('Navigation Error', 'Could not navigate to nearby users screen.');
    }
  };
  
  const fetchAvailableUsers = async () => {
    // Don't attempt to fetch if initialization hasn't completed
    if (!isInitialized) {
      console.log('Skipping fetchAvailableUsers - not yet initialized');
      return [];
    }
    
    try {
      setLoading(true);
      const token = await AsyncStorage.getItem('token');
      const userId = await AsyncStorage.getItem('userId');
      
      // Mock data for fallback with explicit type casting
      const mockPartners = [
        {
          _id: '1',
          name: 'Rahul S.',
          username: 'rahul_s',
          profileImage: undefined,
          location: 'Andheri',
          languages: ['Hindi', 'English'],
          gender: 'Male',
          rating: 4.8,
          distance: '0.3 km',
          mode: 'seeking' as 'seeking'
        },
        {
          _id: '2',
          name: 'Priya M.',
          username: 'priya_m',
          profileImage: undefined,
          location: 'Bandra',
          languages: ['English', 'Marathi'],
          gender: 'Female',
          rating: 4.7,
          distance: '0.7 km',
          mode: 'seeking' as 'seeking'
        },
        {
          _id: '3',
          name: 'Amit K.',
          username: 'amit_k',
          profileImage: undefined,
          location: 'Dadar',
          languages: ['Hindi', 'English', 'Gujarati'],
          gender: 'Male',
          rating: 4.5,
          distance: '1.2 km',
          mode: 'seeking' as 'seeking'
        }
      ] as User[];
      
      if (!token || !userId) {
        console.log('No token or userId found, using mock data');
        setAvailablePartners(mockPartners);
        return mockPartners;
      }
      
      // Don't make a network request if there are no coordinates
      if (!location || location.latitude === 0 || location.longitude === 0) {
        console.log('Invalid location coordinates, using mock data');
        setAvailablePartners(mockPartners);
        return mockPartners;
      }
      
      // Implement a timeout for the network call
      const timeoutPromise = new Promise<null>((_, reject) => {
        setTimeout(() => reject(new Error('Network request timeout')), 5000);
      });
      
      try {
        // Race between actual API call and timeout
        const result = await Promise.race([
          safeApiCall(
            async () => {
              console.log(`Fetching available partners from ${API_URL}/api/users/available-partners`);
              console.log('Request payload:', {
                userId,
                location: {
                  latitude: location.latitude,
                  longitude: location.longitude
                },
                destination: destination,
                maxDistance: 2
              });
            
              const response = await fetch(`${API_URL}/api/users/available-partners`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                  userId,
                  location: {
                    latitude: location.latitude,
                    longitude: location.longitude
                  },
                  destination: destination,
                  maxDistance: 2 // 2km radius
                })
              });
              
              if (!response.ok) {
                throw new Error(`Failed to fetch available partners: ${response.status}`);
              }
              
              return await response.json();
            },
            null
          ),
          timeoutPromise
        ]);
        
        if (result && result.users && result.users.length > 0) {
          console.log('Successfully fetched', result.users.length, 'partners from API');
          setAvailablePartners(result.users);
          return result.users;
        } else {
          console.log('No partners found from API or empty response, using mock data');
          throw new Error('Empty or invalid response from API');
        }
      } catch (networkError) {
        console.warn('Network error in fetchAvailableUsers:', networkError);
        console.log('Using mock data due to network issue');
        setAvailablePartners(mockPartners);
        return mockPartners;
      }
    } catch (error) {
      console.error('Error in fetchAvailableUsers process:', error);
      // Use mock data for demo with explicit type casting
      const fallbackPartners = [
        {
          _id: '1',
          name: 'Rahul S.',
          username: 'rahul_s',
          profileImage: undefined,
          location: 'Andheri',
          languages: ['Hindi', 'English'],
          gender: 'Male',
          rating: 4.8,
          distance: '0.3 km',
          mode: 'seeking' as 'seeking'
        },
        {
          _id: '2',
          name: 'Priya M.',
          username: 'priya_m',
          profileImage: undefined,
          location: 'Bandra',
          languages: ['English', 'Marathi'],
          gender: 'Female',
          rating: 4.7,
          distance: '0.7 km',
          mode: 'seeking' as 'seeking'
        }
      ] as User[];
      
      setAvailablePartners(fallbackPartners);
      return fallbackPartners;
    } finally {
      setLoading(false);
    }
  };

  const sendRideInvite = async (userId: string) => {
    if (!currentRide || !currentRide.id) {
      Alert.alert('Error', 'No active ride to share');
      return;
    }
    
    try {
      setIsLoading(true);
      const token = await AsyncStorage.getItem('token');
      
      const result = await safeApiCall(
        async () => {
          const response = await fetch(`${API_URL}/api/rides/invite`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              rideId: currentRide.id,
              userId: userId
            })
          });
          
          if (!response.ok) {
            throw new Error('Failed to send invite');
          }
          
          return await response.json();
        },
        { success: true, inviteId: `invite-${Date.now()}` }
      );
      
      // Add the new invite to the invites state
      const newInvite = {
        userId,
        rideId: currentRide.id,
        status: 'pending' as 'pending'
      };
      
      setInvites([...invites, newInvite]);
      
      Alert.alert('Success', 'Ride invitation sent successfully');
      console.log('Invite sent to partner', userId);
    } catch (error) {
      console.error('Error sending ride invite:', error);
      Alert.alert('Error', 'Failed to send ride invitation');
    } finally {
      setIsLoading(false);
    }
  };

  const acceptRideInvite = async (inviteId: string) => {
    try {
      setIsLoading(true);
      const token = await AsyncStorage.getItem('token');
      
      const response = await fetch(`${API_URL}/api/rides/accept-invite/${inviteId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('Failed to accept invite');
      }
      
      // Update the invite status in the state
      setInvites(invites.map(invite => 
        invite.userId === inviteId ? { ...invite, status: 'accepted' } : invite
      ));
      
      // Show payment modal
      setShowPaymentModal(true);
    } catch (error) {
      console.error('Error accepting ride invite:', error);
      Alert.alert('Error', 'Failed to accept ride invitation');
    } finally {
      setIsLoading(false);
    }
  };

  const validatePayment = async (partnerId: string) => {
    try {
      setIsLoading(true);
      const token = await AsyncStorage.getItem('token');
      
      // First check if partner is nearby (within 100 meters)
      const response = await fetch(`${API_URL}/api/rides/validate-proximity`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          partnerId,
          location: {
            latitude: location.latitude,
            longitude: location.longitude
          }
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to validate proximity');
      }
      
      const data = await response.json();
      
      if (data.isNearby) {
        // If nearby, proceed with payment validation
        setIsFareSplit(true);
        setSelectedPartner(availablePartners.find(partner => partner._id === partnerId) || null);
        Alert.alert('Success', 'Payment validated and fare split successfully');
      } else {
        Alert.alert('Error', 'Payment validation failed. You must be near your ride partner to split the fare.');
      }
    } catch (error) {
      console.error('Error validating payment:', error);
      Alert.alert('Error', 'Failed to validate payment');
      
      // For demo purposes, still set fare as split
      setIsFareSplit(true);
    } finally {
      setIsLoading(false);
      setShowPaymentModal(false);
    }
  };

  const rateRidePartner = async (partnerId: string, rating: number) => {
    try {
      const token = await AsyncStorage.getItem('token');
      
      const response = await fetch(`${API_URL}/api/users/rate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          userId: partnerId,
          rating,
          rideId: currentRide?.id
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to submit rating');
      }
      
      Alert.alert('Thank You', 'Your rating has been submitted');
    } catch (error) {
      console.error('Error rating partner:', error);
      Alert.alert('Error', 'Failed to submit rating');
    }
  };

  const openProviderApp = async (providerName: string) => {
    // Get current location and destination for ride booking
    const pickup = {
      latitude: location.latitude,
      longitude: location.longitude
    };
    const dropoff = {
      latitude: destinationCoords.latitude,
      longitude: destinationCoords.longitude
    };

    // Specific deep linking schemes with ride booking parameters
    const getUberDeepLink = () => {
      const params = {
        action: 'setPickup',
        pickup: `latitude=${pickup.latitude},longitude=${pickup.longitude}`,
        dropoff: `latitude=${dropoff.latitude},longitude=${dropoff.longitude}`,
        product_id: 'a1111c8c-c720-46c3-8534-2fcdd730040d' // UberX product ID
      };
      const queryString = Object.entries(params)
        .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
        .join('&');
      return `uber://?${queryString}`;
    };

    const getOlaDeepLink = () => {
      const params = {
        pickup_lat: pickup.latitude,
        pickup_lng: pickup.longitude,
        drop_lat: dropoff.latitude,
        drop_lng: dropoff.longitude,
        category: 'mini'
      };
      const queryString = Object.entries(params)
        .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
        .join('&');
      return `com.olacabs.customer://?${queryString}`;
    };

    const deepLinks = {
      'Uber': [
        getUberDeepLink(),
        'uber://',
        'uberapp://'
      ],
      'Ola': [
        getOlaDeepLink(),
        'com.olacabs.customer://',
        'olacabs://'
      ]
    };

    const packageNames = {
      'Uber': 'com.ubercab',
      'Ola': 'com.olacabs.customer'
    };

    try {
      const links = deepLinks[providerName as keyof typeof deepLinks];
      const packageName = packageNames[providerName as keyof typeof packageNames];
      
      if (!links || !packageName) {
        throw new Error('Invalid provider');
      }

      // First check if the app is installed using package name
      const isInstalled = await Linking.canOpenURL(`${packageName}://`);
      
      if (isInstalled) {
        // Try each deep link in sequence
        let opened = false;
        for (const link of links) {
          try {
            await Linking.openURL(link);
            opened = true;
            break;
          } catch (err) {
            console.log(`Failed to open ${link}:`, err);
            continue;
          }
        }

        if (!opened) {
          // If none of the deep links worked but app is installed,
          // try opening the app directly
          await Linking.openURL(`${packageName}://`);
        }
      } else {
        // App is not installed, open Play Store
        await Linking.openURL(`market://details?id=${packageName}`).catch(() => {
          // If market:// scheme fails, use https://
          Linking.openURL(`https://play.google.com/store/apps/details?id=${packageName}`);
        });
      }
    } catch (err) {
      console.error('Error in openProviderApp:', err);
      Alert.alert(
        'Cannot Open App',
        `Unable to open ${providerName} app. Would you like to open the Play Store?`,
        [
          {
            text: 'Cancel',
            style: 'cancel'
          },
          {
            text: 'Open Store',
            onPress: async () => {
              try {
                const packageName = packageNames[providerName as keyof typeof packageNames];
                await Linking.openURL(`market://details?id=${packageName}`).catch(() => {
                  Linking.openURL(`https://play.google.com/store/apps/details?id=${packageName}`);
                });
              } catch (storeErr) {
                Alert.alert('Error', 'Could not open Play Store. Please install the app manually.');
              }
            }
          }
        ]
      );
    }
  };

  const fetchMatchingUsers = useCallback(async () => {
    // Define mock data once at the top for reuse
    const mockUsers = [
      {
        _id: '1',
        name: 'Rahul S.',
        username: 'rahul_s',
        profileImage: undefined,
        location: 'Andheri',
        languages: ['Hindi', 'English'],
        gender: 'Male',
        rating: 4.8,
        distance: '0.3 km',
        mode: 'seeking' as 'seeking'
      },
      {
        _id: '2',
        name: 'Priya M.',
        username: 'priya_m',
        profileImage: undefined,
        location: 'Bandra',
        languages: ['English', 'Marathi'],
        gender: 'Female',
        rating: 4.7,
        distance: '0.7 km',
        mode: 'seeking' as 'seeking'
      }
    ] as User[];
    
    try {
      setLoading(true);
      console.log('Fetching matching users...');
      
      // Get auth data
      const token = await AsyncStorage.getItem('token');
      const userId = await AsyncStorage.getItem('userId');

      if (!token || !userId) {
        console.log('No token or userId found, using mock data');
        setUsers(mockUsers);
        return;
      }

      // Use the enhanced network request with retry
      const result = await safeNetworkRequest(
        async () => {
          // Create an abort controller for the timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

          try {
            const response = await fetch(
              `${API_URL}/api/auth/matching-users/${userId}`,
              {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
                signal: controller.signal, // Use controller's signal instead of AbortSignal.timeout
              }
            );
            
            // Clear the timeout to prevent memory leaks
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ message: `HTTP error ${response.status}` }));
              throw new Error(errorData.message || `HTTP error ${response.status}`);
            }

            const data = await response.json();
            if (!data || !data.users) {
              throw new Error('Invalid response format');
            }
            
            return data;
          } catch (err) {
            // Clear the timeout if there's an error
            clearTimeout(timeoutId);
            throw err;
          }
        },
        { users: mockUsers },
        20000, // 20 second overall timeout
        3      // Allow 3 retries
      );

      // Process the result, whether from API or fallback
      if (result && result.users && Array.isArray(result.users)) {
        console.log('Successfully fetched users:', result.users.length);
        setUsers(result.users);
      } else {
        console.warn('API returned invalid user data format, using mock data');
        setUsers(mockUsers);
      }
    } catch (error) {
      console.error('Unexpected error in fetchMatchingUsers:', error);
      // Fall back to mock data in all error cases
      setUsers(mockUsers);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, []);

  const handleRefresh = useCallback(() => {
    setRefreshing(true);
    fetchMatchingUsers();
  }, [fetchMatchingUsers]);

  // Fetch users when the component mounts
  useEffect(() => {
    fetchMatchingUsers();
  }, [fetchMatchingUsers]);

  // Handle directions button press
  const handleShowDirections = () => {
    if (routeData) {
      setShowDirections(true);
    } else {
      Alert.alert('No Route', 'Please set a destination and search for routes first.');
    }
  };
  
  // Handle close directions
  const handleCloseDirections = () => {
    setShowDirections(false);
  };

  // Function to handle pickup location selection
  const handleLocationSelect = () => {
    // Show options for pickup location
    Alert.alert(
      "Select Pickup Location",
      "Choose an option",
      [
        {
          text: "Use Current Location",
          onPress: getCurrentLocationAndAddress
        },
        {
          text: "Search Location",
          onPress: () => router.push('/location-picker?type=pickup')
        },
        { 
          text: "Cancel", 
          style: "cancel" 
        }
      ]
    );
  };

  // Function to handle destination selection
  const handleDestinationSelect = () => {
    if (isDestinationConfirmed) {
      // If a destination is already confirmed, show an alert to confirm changing
      Alert.alert(
        "Change Destination?",
        "Are you sure you want to change your destination?",
        [
          {
            text: "Cancel",
            style: "cancel"
          },
          { 
            text: "Yes", 
            onPress: () => {
              setIsDestinationConfirmed(false);
              router.push('/location-picker?type=destination');
            }
          }
        ]
      );
      return;
    }
    
    if (!destination.trim()) {
      router.push('/location-picker?type=destination');
      return;
    }
    
    // If destination already has text, navigate to location picker with the text pre-filled
    router.push(`/location-picker?type=destination&text=${encodeURIComponent(destination)}`);
  };

  // Function to clear the destination
  const handleClearDestination = () => {
    setDestination('');
    setDestinationCoords({
      latitude: 0,
      longitude: 0,
    });
    setIsDestinationConfirmed(false);
    setShowProviders(false);
    setRouteData(null);
  };

  return (
    <View style={styles.container}>
      {/* Header Area */}
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Match My Ride</Text>
      </View>

      {/* Map Area - INCREASED HEIGHT but not too large to maintain other UI */}
      <View style={styles.mapContainer}>
        {showDirections ? (
          <RouteDirections 
            steps={routeData?.steps || []}
            totalDistance={routeData?.distance || 0}
            totalDuration={routeData?.duration || 0}
            visible={true}
            onClose={handleCloseDirections}
          />
        ) : isMapLibraryAvailable ? (
          <View style={styles.mapContainer}>
            {renderMapContent()}
          
            <MapAttribution />
          
            {/* Custom Zoom Controls */}
            <View style={styles.zoomControlsContainer}>
              <TouchableOpacity 
                style={styles.zoomButton}
                onPress={() => {
                  if (mapRef.current) {
                    try {
                      // Get current zoom level - if not available, use default
                      const currentZoom = 15;
                      mapRef.current.setCamera({
                        centerCoordinate: [location.longitude, location.latitude],
                        zoomLevel: currentZoom + 1,
                        animationDuration: 300,
                        animationMode: 'easeTo'
                      });
                    } catch (e) {
                      console.warn('Error zooming in:', e);
                    }
                  }
                }}
              >
                <Ionicons name="add" size={28} color="#333" />
              </TouchableOpacity>
            
              <TouchableOpacity 
                style={styles.zoomButton}
                onPress={() => {
                  if (mapRef.current) {
                    try {
                      // Get current zoom level - if not available, use default
                      const currentZoom = 15;
                      mapRef.current.setCamera({
                        centerCoordinate: [location.longitude, location.latitude],
                        zoomLevel: currentZoom - 1,
                        animationDuration: 300,
                        animationMode: 'easeTo'
                      });
                    } catch (e) {
                      console.warn('Error zooming out:', e);
                    }
                  }
                }}
              >
                <Ionicons name="remove" size={28} color="#333" />
              </TouchableOpacity>
            </View>
            
            {/* Location button */}
            <TouchableOpacity 
              style={styles.locationButton}
              onPress={() => {
                getCurrentLocationAndAddress();
                if (mapRef.current) {
                  try {
                    mapRef.current.setCamera({
                      centerCoordinate: [location.longitude, location.latitude],
                      zoomLevel: 15,
                      animationDuration: 500,
                      animationMode: 'flyTo'
                    });
                  } catch (e) {
                    console.warn('Error centering on location:', e);
                  }
                }
              }}
            >
              <Ionicons name="navigate" size={28} color="#0066CC" />
            </TouchableOpacity>
          </View>
        ) : (
          <FallbackMap initialCoordinates={[location.longitude, location.latitude]} />
        )}
      </View>
      
      {/* Search Container - RESTORED */}
      <View style={styles.searchContainer}>
        <View style={styles.inputContainer}>
          {/* Pickup Input */}
          <TouchableOpacity
            style={styles.input}
            onPress={handleLocationSelect}
          >
            <Ionicons name="location" size={20} color="#0066CC" />
            <Text style={styles.inputText}>
              {pickupLocation || 'Select pickup location'}
            </Text>
            {pickupLocation === 'Current Location' && (
              <View style={styles.currentLocationButton}>
                <Ionicons name="navigate" size={12} color="#0066CC" />
                <Text style={styles.currentLocationText}>Current</Text>
              </View>
            )}
          </TouchableOpacity>
          
          {/* Destination Input */}
          <TouchableOpacity
            style={styles.input}
            onPress={handleDestinationSelect}
          >
            <Ionicons name="flag" size={20} color="#D83C54" />
            {isDestinationConfirmed ? (
              <View style={styles.confirmedDestination}>
                <View style={styles.destinationInputContainer}>
                  <Text style={styles.inputText}>{destination}</Text>
                </View>
                <TouchableOpacity onPress={handleClearDestination}>
                  <Ionicons name="close-circle" size={20} color="#999" />
                </TouchableOpacity>
              </View>
            ) : (
              <Text style={[styles.inputText, !destination ? styles.placeholderText : null]}>
                {destination || 'Where to?'}
              </Text>
            )}
          </TouchableOpacity>
        </View>
        
        <View style={styles.optionsContainer}>
          <TouchableOpacity 
            style={[styles.optionButton, styles.compareRidesButton]}
            onPress={handleSearch}
            disabled={isLoading || !destination || !isDestinationConfirmed}
          >
            <Ionicons name="car" size={16} color="white" />
            <Text style={styles.optionButtonText}>Find Rides</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[styles.optionButton, { backgroundColor: '#28a745' }]}
            onPress={handleShowDirections}
            disabled={!routeData}
          >
            <Ionicons name="map" size={16} color="white" />
            <Text style={styles.optionButtonText}>Directions</Text>
          </TouchableOpacity>
        </View>
      </View>
      
      {/* Providers Container - RESTORED */}
      {showProviders && !isLoading && (
        <ScrollView style={styles.contentContainer}>
          <View style={styles.providersContainer}>
            <Text style={styles.sectionTitle}>Available Ride Options</Text>
            
            <View style={styles.providersGrid}>
              {providers.map((provider, index) => (
                <TouchableOpacity 
                  key={index} 
                  style={styles.providerCard}
                  onPress={() => selectRideProvider(provider)}
                >
                  <Text style={styles.providerName}>{provider.name}</Text>
                  <Text>{provider.eta}</Text>
                  <Text style={{ fontWeight: 'bold', color: '#0066CC' }}>{provider.fare}</Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
          
          {/* Current Ride Section - RESTORED */}
          {currentRide && (
            <View style={styles.currentRideContainer}>
              <Text style={styles.sectionTitle}>Current Ride</Text>
              
              <View style={styles.rideItem}>
                <View style={styles.rideIconContainer}>
                  <Ionicons 
                    name={currentRide.provider === 'Uber' ? 'car-sport' : 'car'} 
                    size={24} 
                    color="#0066CC" 
                  />
                </View>
                
                <View style={styles.rideDetails}>
                  <View style={styles.rideHeader}>
                    <Text style={styles.rideProvider}>{currentRide.provider}</Text>
                    <Text style={styles.rideDistance}>{currentRide.distance}</Text>
                  </View>
                  
                  <Text style={styles.rideLocation}>From: {currentRide.from}</Text>
                  <Text style={styles.rideLocation}>To: {currentRide.to}</Text>
                  
                  <View style={{flexDirection: 'row', justifyContent: 'space-between'}}>
                    <Text style={styles.rideFare}>
                      {currentRide.fare} {isFareSplit && <Text style={styles.splitFareText}>(Split)</Text>}
                    </Text>
                    {selectedPartner && (
                      <Text style={{fontStyle: 'italic'}}>
                        Sharing with {selectedPartner.name}
                      </Text>
                    )}
                  </View>
                </View>
              </View>
              
              <View style={styles.rideActions}>
                <TouchableOpacity 
                  style={[styles.actionButton, styles.findPartnersButton]}
                  onPress={findRidePartners}
                >
                  <Ionicons name="people" size={18} color="white" />
                  <Text style={styles.actionButtonText}>Find Partners</Text>
                </TouchableOpacity>
                
                <TouchableOpacity 
                  style={[styles.actionButton, styles.openAppButton]}
                  onPress={() => openProviderApp(currentRide.provider)}
                >
                  <Ionicons name="open" size={18} color="white" />
                  <Text style={styles.actionButtonText}>Open App</Text>
                </TouchableOpacity>
              </View>
            </View>
          )}
            
          {/* Available Partners Section - RESTORED */}
          {showPartners && availablePartners.length > 0 && (
            <View style={styles.availablePartnersContainer}>
              <Text style={styles.sectionTitle}>Available Partners</Text>
              {availablePartners.map((partner) => (
                <View key={partner._id} style={styles.partnerCard}>
                  <View style={styles.partnerHeader}>
                    <View style={styles.partnerProfile}>
                      <View style={styles.avatarContainer}>
                        <Ionicons name="person" size={20} color="#0066CC" />
                      </View>
                      <View>
                        <Text style={styles.partnerName}>{partner.name}</Text>
                        <Text style={styles.partnerDistance}>{partner.distance}</Text>
                      </View>
                    </View>
                    
                    <View style={styles.ratingContainer}>
                      <Ionicons name="star" size={14} color="#FFD700" />
                      <Text style={styles.ratingText}>{partner.rating}</Text>
                    </View>
                  </View>
                  
                  <View style={styles.partnerDetails}>
                    <View style={styles.detailItem}>
                      <Ionicons name="location" size={16} color="#666" />
                      <Text style={styles.detailText}>{partner.location}</Text>
                    </View>
                    
                    <View style={styles.detailItem}>
                      <Ionicons name="chatbubbles" size={16} color="#666" />
                      <Text style={styles.detailText}>
                        {partner.languages.join(', ')}
                      </Text>
                    </View>
                  </View>
                  
                  <View style={styles.actionButtons}>
                    <TouchableOpacity style={styles.messageButton}>
                      <Ionicons name="chatbubble-outline" size={16} color="#0066CC" />
                      <Text style={styles.messageButtonText}>Message</Text>
                    </TouchableOpacity>
                    
                    <TouchableOpacity 
                      style={styles.inviteButton}
                      onPress={() => sendRideInvite(partner._id)}
                    >
                      <Text style={styles.inviteButtonText}>Invite</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              ))}
            </View>
          )}
          
          {/* Loading indicator - RESTORED */}
          {isLoading && (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color="#0066CC" />
              <Text style={styles.loadingText}>Loading...</Text>
            </View>
          )}
        </ScrollView>
      )}
    </View>
  );
}

// The default export that Expo Router expects
export default Main;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  // Replace map style
  mapContainer: {
    height: '45%', // Reduced from 70% to leave room for other UI elements
    width: '100%',
    position: 'relative',
  },
  map: {
    flex: 1,
    width: '100%',
    height: '100%',
  },
  // Add marker styles
  markerContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    width: 40,
    height: 40,
  },
  userMarker: {
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  destinationMarker: {
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  // Add map controls
  mapControls: {
    position: 'absolute',
    right: 16,
    top: 100, // Changed from bottom to top for better visibility
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 12,
    padding: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 6,
  },
  mapControlButton: {
    backgroundColor: 'white',
    borderRadius: 30,
    width: 50,
    height: 50,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
    marginVertical: 5,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  searchContainer: {
    backgroundColor: 'white',
    paddingHorizontal: 15,
    paddingTop: 10,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
  },
  inputContainer: {
    backgroundColor: 'white',
    borderRadius: 8,
    overflow: 'hidden',
    marginBottom: 10,
  },
  input: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
  },
  inputText: {
    marginLeft: 10,
    flex: 1,
    fontSize: 16,
    color: '#333',
  },
  optionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 10,
  },
  optionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 8,
    paddingVertical: 12,
    flex: 1,
  },
  compareRidesButton: {
    backgroundColor: '#0066CC',
    marginRight: 5,
  },
  optionButtonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 14,
    marginLeft: 8,
  },
  contentContainer: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f8f8',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#555',
  },
  providersContainer: {
    backgroundColor: 'white',
    margin: 12,
    borderRadius: 12,
    padding: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333',
  },
  providersGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  providerCard: {
    width: '31%',
    backgroundColor: '#F8F9FA',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#EEEEEE',
  },
  providerName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  currentRideContainer: {
    backgroundColor: 'white',
    margin: 12,
    borderRadius: 12,
    padding: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  rideItem: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
    paddingBottom: 15,
  },
  rideIconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#E6F0FF',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 15,
  },
  rideDetails: {
    flex: 1,
  },
  rideHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  rideProvider: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  rideDistance: {
    color: '#666',
  },
  rideLocation: {
    color: '#555',
    marginBottom: 3,
  },
  rideFare: {
    fontWeight: '600',
    color: '#0066CC',
    marginTop: 5,
  },
  splitFareText: {
    fontStyle: 'italic',
    color: '#28a745',
  },
  detailsButton: {
    justifyContent: 'center',
    paddingLeft: 10,
  },
  rideActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 15,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 8,
    paddingVertical: 12,
    flex: 1,
  },
  findPartnersButton: {
    backgroundColor: '#0066CC',
    marginRight: 8,
  },
  openAppButton: {
    backgroundColor: '#28a745',
    marginLeft: 8,
  },
  actionButtonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
    marginLeft: 8,
  },
  partnerSection: {
    marginTop: 15,
    borderTopWidth: 1,
    borderTopColor: '#EEEEEE',
    paddingTop: 15,
  },
  partnerSectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  partnerCard: {
    backgroundColor: '#F8F9FA',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#EEEEEE',
  },
  partnerHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  partnerProfile: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatarContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#E6F0FF',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 10,
  },
  partnerName: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  partnerDistance: {
    fontSize: 14,
    color: '#666',
  },
  rateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF9E6',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 15,
  },
  rateButtonText: {
    marginLeft: 5,
    fontWeight: '500',
  },
  availablePartnersContainer: {
    backgroundColor: 'white',
    margin: 12,
    borderRadius: 12,
    padding: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF9E6',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  ratingText: {
    marginLeft: 3,
    color: '#333',
    fontWeight: '500',
  },
  partnerDetails: {
    marginTop: 10,
    marginBottom: 10,
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 5,
  },
  detailText: {
    marginLeft: 8,
    color: '#555',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  messageButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#F0F0F0',
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    flex: 1,
    marginRight: 8,
  },
  messageButtonText: {
    color: '#0066CC',
    fontWeight: '500',
    marginLeft: 5,
  },
  inviteButton: {
    backgroundColor: '#0066CC',
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
    marginLeft: 8,
  },
  inviteButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  modalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
    width: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  modalText: {
    fontSize: 14,
    color: '#555',
    marginBottom: 20,
    textAlign: 'center',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  modalCancelButton: {
    backgroundColor: '#F0F0F0',
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 15,
    alignItems: 'center',
    flex: 1,
    marginRight: 8,
  },
  modalCancelButtonText: {
    color: '#333',
    fontWeight: '500',
  },
  modalConfirmButton: {
    backgroundColor: '#0066CC',
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 15,
    alignItems: 'center',
    flex: 1,
    marginLeft: 8,
  },
  modalConfirmButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  mapUnavailableContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
  },
  mapUnavailableText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    padding: 20,
  },
  confirmedDestination: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingLeft: 10,
  },
  destinationInputContainer: {
    flex: 1,
  },
  customMarker: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: 'white',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#0066CC',
  },
  customDestinationMarker: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: 'white',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2, 
    borderColor: '#D83C54',
  },
  markerInner: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center',
  },
  currentLocationButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#E6F0FF',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 15,
    marginLeft: 'auto',
    borderWidth: 1,
    borderColor: '#BCD5F7',
  },
  currentLocationText: {
    color: '#0066CC',
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  placeholderText: {
    color: '#999',
  },
  locationButton: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    backgroundColor: 'white',
    borderRadius: 30,
    width: 60,
    height: 60,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
    zIndex: 10,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  header: {
    backgroundColor: '#0066CC',
    padding: 10,
    alignItems: 'center',
    justifyContent: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
  },
  headerTitle: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  zoomControlsContainer: {
    position: 'absolute',
    right: 20,
    top: '40%', // Position higher on the screen 
    transform: [{ translateY: -50 }],
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
    zIndex: 10,
  },
  zoomButton: {
    width: 44, // Make buttons slightly larger
    height: 44, // Make buttons slightly larger
    borderRadius: 22,
    backgroundColor: 'white',
    alignItems: 'center',
    justifyContent: 'center',
    marginVertical: 5,
    borderWidth: 1,
    borderColor: '#ddd',
  },
});